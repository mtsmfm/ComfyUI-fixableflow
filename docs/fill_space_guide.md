# Fill Space Node 使用ガイド

## 概要
ComfyUI-LayerDividerに追加された隙間埋めノードです。BFS（幅優先探索）アルゴリズムを使用して、線画の白い隙間を最も近い黒い部分（線）の色で塗りつぶします。これにより、線画の隙間を自然に補完できます。

## ノード種類

### 1. LayerDivider - Fill Space
基本的な隙間埋めノード

**入力:**
- `binary_image`: バイナリ画像（線画）
- `flat_image`: 塗り画像（Split Areaで作成した画像など）
- `invert_binary`: バイナリ画像を反転（デフォルト: True）
- `use_optimized`: 最適化アルゴリズムを使用（デフォルト: True）

**出力:**
- `filled_image`: 隙間が埋められた画像
- `preview`: 処理前後の比較画像

### 2. LayerDivider - Fill Space Advanced
高度な隙間埋めノード

**入力:**
- `binary_image`: バイナリ画像（線画）
- `flat_image`: 塗り画像
- `invert_binary`: バイナリ画像を反転
- `search_directions`: 探索方向
  - `4-way`: 上下左右の4方向
  - `8-way`: 斜めを含む8方向
- `fill_mode`: 塗りつぶしモード
  - `nearest`: 最近傍の色で塗る
  - `average`: 周囲の平均色で塗る
  - `gradient`: グラデーション補間
- `threshold`: 二値化閾値（0-255）
- `blur_result`: 結果をぼかす
- `blur_size`: ぼかしのカーネルサイズ
- `output_mode`: 出力モード
  - `filled`: 塗りつぶし結果
  - `distance_map`: 距離マップの可視化
  - `comparison`: 前後比較
  - `overlay`: オーバーレイ表示

**出力:**
- `filled_image`: 隙間が埋められた画像
- `visualization`: 可視化画像
- `original`: 元の塗り画像
- `fill_mask`: 塗りつぶしマスク

## アルゴリズムの説明

### BFS（幅優先探索）による隙間埋め
1. **距離マップの構築**: 各白ピクセルから最も近い黒ピクセルまでの距離を計算
2. **最近傍の特定**: BFSを使って各白ピクセルの最近傍黒ピクセルを見つける
3. **色の転写**: 最近傍の黒ピクセルに対応する塗り画像の色を白ピクセルに適用

### 最適化版アルゴリズム
- 黒ピクセルから外側に向かって探索することで計算量を削減
- 距離マップを一度に構築してメモリアクセスを効率化

## 使用例

### 基本的なワークフロー
```
[線画] → [Split Area] → [Fill Space] → [最終画像]
              ↓              ↑
         [塗り画像] →→→→→→→→→┘
```

### 完全なパイプライン
```
[元画像] → [Extract Line Art] → [線画]
                ↓                  ↓
         [Fill Area] → [Split Area] → [Fill Space]
                              ↓            ↓
                        [領域マップ]  [完成画像]
```

### Split Areaとの連携
```
[線画] → [Split Area] → [色分け画像]
    ↓           ↓            ↓
[二値化] →→→ [Fill Space] ←←←┘
                ↓
          [隙間なし画像]
```

## パラメータ調整のコツ

### invert_binary（画像反転）
- **True**: 通常の線画（黒い線、白い背景）の場合
- **False**: 反転画像（白い線、黒い背景）の場合

### search_directions（探索方向）
- **4-way**: 高速、直交方向のみ
- **8-way**: より自然な結果、斜め方向も考慮

### fill_mode（塗りつぶしモード）
- **nearest**: 最も忠実、シャープな結果
- **average**: スムーズな遷移
- **gradient**: 自然なグラデーション（インペインティング）

### threshold（二値化閾値）
- **低い値（0-100）**: より多くを線として認識
- **中程度（100-150）**: 標準的な設定
- **高い値（150-255）**: 濃い線のみ認識

## 処理の流れ

1. **前処理**: バイナリ画像の二値化と反転
2. **距離計算**: BFSで各ピクセルの最近傍を特定
3. **色の転写**: 塗り画像から対応する色を取得
4. **後処理**: オプションでぼかしやブレンド
5. **可視化**: 選択されたモードで出力

## 活用シーン

- **線画の隙間補完**: 不完全な線画の隙間を埋める
- **セグメンテーションの改善**: Split Area後の隙間を解消
- **アンチエイリアシング**: 線の周囲を滑らかに
- **マスクの拡張**: 線画マスクを塗り領域に拡張

## トラブルシューティング

### 隙間が埋まらない場合
- thresholdを調整して二値化を改善
- invert_binaryの設定を確認
- 線画が完全に黒白になっているか確認

### 色が正しくない場合
- fill_modeを変更してみる
- 8-way探索を試す
- 塗り画像の解像度を確認

### 処理が遅い場合
- use_optimizedをTrueに設定
- 4-way探索を使用
- 画像サイズを縮小

## 他のノードとの連携

### Split Area → Fill Space
Split Areaで作成した色分け画像の隙間を埋めることで、完全な塗り分けを実現

### Fill Area → Fill Space
均一化された塗りに対してFill Spaceを適用することで、より滑らかな結果を得る

### Extract Line Art → Fill Space
抽出した線画をマスクとして使用し、元画像の色情報を保持しながら隙間を埋める

## 技術詳細

### BFSアルゴリズムの利点
- 最短経路保証: 常に最も近いピクセルを見つける
- 効率的: O(n)の計算量（nはピクセル数）
- 安定: 同じ入力に対して同じ結果

### メモリ使用量
- 距離マップ: 画像サイズ × float32
- 最近傍マップ: 画像サイズ × 2 × int32
- 大きな画像では相応のメモリが必要

## 注意事項

- 入力画像のサイズが一致している必要があります
- 極めて大きな隙間の場合、処理時間が長くなる可能性があります
- gradient モードではOpenCVのインペインティング機能を使用
- 最適化版は通常版より高速ですが、わずかに多くのメモリを使用します
